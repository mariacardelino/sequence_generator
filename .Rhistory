mutate(ending = str_sub(pos96, -1)) %>%
pull(ending) %>%
unique() %>%
sort()
## For each rack number in study_samples (expecting 2),
## create new df rack#_samples with the samples from that rack only
rack_samples_list <- list()
for(ending in unique_endings) {
# Filter samples and store in the list with a named entry
rack_df <- study_samples %>% filter(str_ends(pos96, ending))
rack_samples_list[[paste0("rack", ending, "_samples")]] <- rack_df
# Print the number of rows
cat(paste0("rack", ending, "_samples: ", nrow(rack_df), " rows\n"))
}
View(rack_samples_list)
for(ending in unique_endings) {
# Filter samples and store in the list with a named entry
rack_df <- study_samples %>% filter(str_ends(pos96, ending))
rack_samples_list[[paste0("rack", ending, "_samples")]] <- rack_df
# Print statement
cat(paste0(nrow(rack_samples_list), "racks of study samples\n"))
cat(paste0("rack", ending, "_samples: ", nrow(rack_df), " rows\n"))
}
for(ending in unique_endings) {
# Filter samples and store in the list with a named entry
rack_df <- study_samples %>% filter(str_ends(pos96, ending))
rack_samples_list[[paste0("rack", ending, "_samples")]] <- rack_df
cat(paste0("rack", ending, "_samples: ", nrow(rack_df), " rows\n"))
}
# Print statement
cat(paste0(nrow(rack_samples_list), "racks of study samples\n"))
nrow(rack_samples_list)
length(rack_samples_list)
# Print statement
cat(paste0(length(rack_samples_list), "racks of study samples\n"))
# Print statement
cat(paste0(length(rack_samples_list), " racks of study samples\n"))
## create new df rack#_samples with the samples from that rack only
rack_samples_list <- list()
for(ending in unique_endings) {
# Filter samples and store in the list with a named entry
rack_df <- study_samples %>% filter(str_ends(pos96, ending))
rack_samples_list[[paste0("rack", ending, "_samples")]] <- rack_df
cat(paste0("rack", ending, "_samples: ", nrow(rack_df), " rows\n"))
}
# Print statement
cat(paste0(length(rack_samples_list), " racks of study samples\n"))
study_racks <- length(rack_samples_list)
study_racks
if(study_racks == 2) {
rack1 <- rack_samples_list[1]
rack1_num <- nrow(rack1)
rack2 <- rack_samples_list[2]
rack2_num <- nrow(rack2)
} else if (study_racks == 1) {
} else if (study_racks == 0) {
cat("Error occurred. No study racks found in grouping process.")
}
study_racks <- length(rack_samples_list)
if(study_racks == 2) {
rack1 <- rack_samples_list[[1]]
rack1_num <- nrow(rack1)
rack2 <- rack_samples_list[[2]]
rack2_num <- nrow(rack2)
} else if (study_racks == 1) {
} else if (study_racks == 0) {
cat("Error occurred. No study racks found in grouping process.")
}
plit_methods <- c(TRUE, TRUE)
split_methods <- c(TRUE, TRUE)
split_methods[[1]]
if(study_racks == 2) {
split <- c(TRUE, TRUE)
rack1 <- rack_samples_list[[1]]
rack1_num <- nrow(rack1)
# If the first rack has less than 60 samples, do it all in one chunk
if(rack1_num < 60) {
split[[1]] <- FALSE
}
rack2 <- rack_samples_list[[2]]
rack2_num <- nrow(rack2)
# If the second rack has less than 60 samples, do it all in one chunk
if(rack2_num < 60) {
split[[2]] <- FALSE
}
} else if (study_racks == 1) {
split <-TRUE
rack1 <- rack_samples_list[[1]]
rack1_num <- nrow(rack1)
# If the rack rack has less than 60 samples, do it all in one chunk
if(rack1_num < 60) {
split <- FALSE
}
} else if (study_racks == 0) {
cat("Error occurred. No study racks found in grouping process.")
} else if (study_racks == 3) {
cat("3 study racks found. Not coded yet!")
}
study_racks
rack_samples_list <- list()
for(ending in unique_endings) {
# Filter samples and store in the list with a named entry
rack_df <- study_samples %>% filter(str_ends(pos96, ending))
rack_samples_list[[paste0("rack", ending, "_samples")]] <- rack_df
cat(paste0("rack", ending, "_samples: ", nrow(rack_df), " rows\n"))
}
study_racks <- length(rack_samples_list)
# For now, assume 2 study racks...
if(study_racks == 2) {
split1 <- TRUE
cat("2 study racks found")
rack1 <- rack_samples_list[[1]]
rack1_num <- nrow(rack1)
# If the first rack has less than 60 samples, do it all in one chunk
if(rack1_num < 60) {
split1 <- FALSE
}
split2 <- TRUE
rack2 <- rack_samples_list[[2]]
rack2_num <- nrow(rack2)
# If the second rack has less than 60 samples, do it all in one chunk
if(rack2_num < 60) {
split2 <- FALSE
}
} else if (study_racks == 1) {
cat("Only 1 study rack found")
split1 <-TRUE
rack1 <- rack_samples_list[[1]]
rack1_num <- nrow(rack1)
# If the rack rack has less than 60 samples, do it all in one chunk
if(rack1_num < 60) {
split1 <- FALSE
}
} else if (study_racks == 0) {
cat("Error occurred. No study racks found in grouping process.")
} else if (study_racks == 3) {
cat("3 study racks found. Not coded yet!")
}
# Separate and group by study sample plate
# Find all unique endings (last character) of pos96 column
unique_endings <- study_samples %>%
mutate(ending = str_sub(pos96, -1)) %>%
pull(ending) %>%
unique() %>%
sort()
## For each rack number in study_samples (expecting 2),
## create new df rack#_samples with the samples from that rack only
rack_samples_list <- list()
for(ending in unique_endings) {
# Filter samples and store in the list with a named entry
rack_df <- study_samples %>% filter(str_ends(pos96, ending))
rack_samples_list[[paste0("rack", ending, "_samples")]] <- rack_df
cat(paste0("rack", ending, "_samples: ", nrow(rack_df), " rows\n"))
}
study_racks <- length(rack_samples_list)
# For now, assume 2 study racks...
if(study_racks == 2) {
split1 <- TRUE
cat("2 study racks found")
rack1 <- rack_samples_list[[1]]
rack1_num <- nrow(rack1)
# If the first rack has less than 60 samples, do it all in one chunk
if(rack1_num < 60) {
split1 <- FALSE
}
split2 <- TRUE
rack2 <- rack_samples_list[[2]]
rack2_num <- nrow(rack2)
# If the second rack has less than 60 samples, do it all in one chunk
if(rack2_num < 60) {
split2 <- FALSE
}
} else if (study_racks == 1) {
cat("Only 1 study rack found")
split1 <-TRUE
rack1 <- rack_samples_list[[1]]
rack1_num <- nrow(rack1)
# If the rack rack has less than 60 samples, do it all in one chunk
if(rack1_num < 60) {
split1 <- FALSE
}
} else if (study_racks == 0) {
cat("Error occurred. No study racks found in grouping process.")
} else if (study_racks == 3) {
cat("3 study racks found. Not coded yet!")
}
first_half_size <- rack1_num/2
# Based on number of racks found, then size of each rack.
if(study_racks == 2) {
split1 <- TRUE
cat("2 study racks found")
rack1 <- rack_samples_list[[1]]
rack1_num <- nrow(rack1)
first_half_size <- rack1_num/2
# If the first rack has less than 60 samples, do it all in one chunk
if(rack1_num < 60) {
split1 <- FALSE
}
split2 <- TRUE
rack2 <- rack_samples_list[[2]]
rack2_num <- nrow(rack2)
second_half_size <- rack2_num/2
# If the second rack has less than 60 samples, do it all in one chunk
if(rack2_num < 60) {
split2 <- FALSE
}
} else if (study_racks == 1) {
cat("Only 1 study rack found")
split1 <-TRUE
rack1 <- rack_samples_list[[1]]
rack1_num <- nrow(rack1)
# If the rack rack has less than 60 samples, do it all in one chunk
if(rack1_num < 60) {
split1 <- FALSE
}
} else if (study_racks == 0) {
cat("Error occurred. No study racks found in grouping process.")
} else if (study_racks == 3) {
cat("3 study racks found. Not coded yet!")
}
source('R:/diwalke/LC/Run_Lists/Sequence_Generator_July25/RUN.R')
# Change the wd to the folder the app is in - MORE ROBUST changed 5/30
v <- getwd()
if (requireNamespace("rstudioapi", quietly = TRUE)) {
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
}
# Change the wd to the folder the app is in - MORE ROBUST changed 5/30
v <- getwd()
# Change the wd to the folder the app is in - MORE ROBUST changed 5/30
v <- getwd()
library(this.path)
# List of required packages
required_packages <- c(
"openxlsx", "shinyjs", "tools",
"shiny", "readr", "dplyr",
"plotly", "readxl", "shinyFiles", "stringr", "this.path"
)
# Install any that are missing
for (pkg in required_packages) {
if (!require(pkg, character.only = TRUE)) {
install.packages(pkg, dependencies = TRUE)
library(pkg, character.only = TRUE)
} else {
library(pkg, character.only = TRUE)
}
}
setwd(this.dir())
# Change the wd to the folder the app is in - MORE ROBUST changed 5/30
v <- getwd()
source('RUN.R')
runApp('App')
View(qaqcs)
source('RUN.R')
runApp('App')
runApp('App')
load("App/Mapping/map.Rdata")  # loads 'df' (96-positions and orders) and 'map' (384-positions)
# Old combined inventory: changed 7/21
#inventory_file_path <<- "TestCopy_250409_CLU0120_Plate_Loading_Order_Updated-Again.xlsx"
# Inventory
q_filepath <- "QAQCS.xlsx"
s_filepath <- "Samples.xlsx"
qaqcs <- read_excel(q_filepath, sheet = "QAQCs")
samples <- read_excel(s_filepath, sheet = "Samples")
# altering?
qaqc_inventory <- qaqcs
sample_inventory <- samples
runApp('App')
runApp('App')
View(study_samples)
## LOGIN #############################################
res <- POST(
url = paste0(base_url, "/sessions"),
content_type_json(),
body = list(
loginName = username,
password = password,
domainName = "openspecimen"
), encode = "json"
)
library(httr)
library(jsonlite)
library(dplyr)
base_url <- "https://openspecimen-dev.emory.edu/openspecimen/rest/ng"
username <- 'CLUES_API'
password <- '1518Clifton'
## LOGIN #############################################
res <- POST(
url = paste0(base_url, "/sessions"),
content_type_json(),
body = list(
loginName = username,
password = password,
domainName = "openspecimen"
), encode = "json"
)
if (status_code(res) == 200) {
body <- content(res, "parsed")
token <- body$resetPasswordToken   # Try this
cat("Login successful\n")
} else {
stop(paste("Login failed:", status_code(res)))
} # success!
library(httr)
library(jsonlite)
library(dplyr)
base_url <- "https://openspecimen-dev.emory.edu/openspecimen/rest/ng"
username <- 'CLUES_API'
password <- '1518Clifton'
## LOGIN #############################################
res <- POST(
url = paste0(base_url, "/sessions"),
content_type_json(),
body = list(
loginName = username,
password = password,
domainName = "openspecimen"
), encode = "json"
)
if (status_code(res) == 200) {
body <- content(res, "parsed")
token <- body$resetPasswordToken
#token <- body$resetPasswordToken   # Try this
cat("Login successful\n")
} else {
stop(paste("Login failed:", status_code(res)))
} # this says success....
token
## LOGIN #############################################
res <- POST(
url = paste0(base_url, "/sessions"),
content_type_json(),
body = list(
loginName = username,
password = password,
domainName = "openspecimen"
), encode = "json"
)
if (status_code(res) == 200) {
body <- content(res, "parsed")
token <- body$Token
#token <- body$resetPasswordToken   # This gives a token
cat("Login successful\n")
} else {
stop(paste("Login failed:", status_code(res)))
} # this says success....
token
source('RUN.R')
source('RUN.R')
warnings()
View(qaqc_inventory)
qaqcs <- read_excel(q_filepath, sheet = "QAQCs")
colnames(qaqcs)
sapply(qaqcs, class)
qaqcs <- read_excel(q_filepath, sheet = "QAQCs", col_types = "character")
qaqcs <- read_excel(q_filepath, sheet = "QAQCs", col_types = "text")
qaqcs$Analyzed <- as.logical(qaqcs$Analyzed)
sapply(qaqcs, class)
samples <- read_excel(s_filepath, sheet = "Samples")
colnames(samples)
sapply(samples,class)
samples <- read_excel(s_filepath, sheet = "Samples", col_types = "text")
samples$Analyzed <- as.logical(samples$Analyzed)
sapply(samples,class)
source('RUN.R')
source('RUN.R')
source('RUN.R')
source('RUN.R')
heck_braces <- function(code_lines) {
stack <- list()
line_number <- 0
for (line in code_lines) {
line_number <- line_number + 1
for (char in strsplit(line, "")[[1]]) {
if (char %in% c("{", "(")) {
stack[[length(stack) + 1]] <- list(char = char, line = line_number)
} else if (char %in% c("}", ")")) {
if (length(stack) == 0) {
cat("Unmatched closing", char, "at line", line_number, "\n")
return()
}
last <- stack[[length(stack)]]
stack <- stack[-length(stack)]
if ((last$char == "{" && char != "}") || (last$char == "(" && char != ")")) {
cat("Mismatched", last$char, "opened at line", last$line,
"and closed by", char, "at line", line_number, "\n")
return()
}
}
}
}
if (length(stack) > 0) {
last <- stack[[length(stack)]]
cat("Unclosed", last$char, "opened at line", last$line, "\n")
} else {
cat("All braces/parentheses are balanced.\n")
}
}
code <- readLines("server.R")  # Or just use a character vector of your function body
code <- readLines("server.R")
code <- readLines("R:\diwalke\LC\Run_Lists\Sequence_Generator_July25\App\server.R")
code <- readLines("R:/diwalke/LC/Run_Lists/Sequence_Generator_July25/App/server.R")
check_braces(code)
check_braces <- function(code_lines) {
stack <- list()
line_number <- 0
for (line in code_lines) {
line_number <- line_number + 1
for (char in strsplit(line, "")[[1]]) {
if (char %in% c("{", "(")) {
stack[[length(stack) + 1]] <- list(char = char, line = line_number)
} else if (char %in% c("}", ")")) {
if (length(stack) == 0) {
cat("Unmatched closing", char, "at line", line_number, "\n")
return()
}
last <- stack[[length(stack)]]
stack <- stack[-length(stack)]
if ((last$char == "{" && char != "}") || (last$char == "(" && char != ")")) {
cat("Mismatched", last$char, "opened at line", last$line,
"and closed by", char, "at line", line_number, "\n")
return()
}
}
}
}
if (length(stack) > 0) {
last <- stack[[length(stack)]]
cat("Unclosed", last$char, "opened at line", last$line, "\n")
} else {
cat("All braces/parentheses are balanced.\n")
}
}
check_braces(code)
source('RUN.R')
return(invisible(TRUE)) # this big function is not meant to return anyting, just generate csv
source('RUN.R')
View(final_plate_data)
source('RUN.R')
source('RUN.R')
View(final_plate_data)
source('RUN.R')
runApp('App')
source('RUN.R')
source('RUN.R')
#test 8/8
filepath <- "C;\Users\mecarde\Downloads"
#test 8/8
filepath <- "C:\Users\mecarde\Downloads"
#test 8/8
filepath <- "C:\sers\mecarde\Downloads"
unique <- get_unique_filename(filepath)
directory <- filepath
### Function to get a unique filename (for saving, so it's not overwritten)
get_unique_filename <- function(filepath) {
original_path <- filepath
counter <- 1
# Extract the file extension and base path
file_ext <- tools::file_ext(filepath)
if (file_ext != "") {
base_path <- sub(paste0("\\.", file_ext, "$"), "", filepath)
file_ext <- paste0(".", file_ext)
} else {
base_path <- filepath
file_ext <- ""
}
# Check if file exists and increment counter until we find a unique name
while (file.exists(filepath)) {
debug_log(paste("File already exists:", filepath))
filepath <- paste0(base_path, " (", counter, ")", file_ext)
counter <- counter + 1
debug_log(paste("Trying new filename:", filepath))
}
# If the filename changed, log it
if (filepath != original_path) {
debug_log(paste("Original filename already exists. Using new filename:", filepath))
}
return(filepath)
}
filepath <- r"(C:\Users\Documents\myfile.txt)"
print(filepath)
suggested_output_path <- sprintf('R:\diwalke\1-RAW Files/230908-RawFiles_LC-Exploris120-%s\%s_%s_%s\3-Sequence_Files', name, study, date, machine)
suggested_output_path <- sprintf(r'(R:\diwalke\1-RAW Files\230908-RawFiles_LC-Exploris120-%s\%s_%s_%s\3-Sequence_Files)', name, study, date, machine)
name <- 'Nancy'
study <- 'CLU0120'
machine <- 'C18'
suggested_output_path <- sprintf(r'(R:\diwalke\1-RAW Files\230908-RawFiles_LC-Exploris120-%s\%s_%s\3-Sequence_Files)', name, study, machine) #REMOVED DATE
suggested_output_path
filename_value <- "CLU0120_04_250808_C18"
directory <- suggested_output_path
# Default folder/sequence filename
sequence_filepath <- file.path(directory, filename_value)
sequence_filepath
# Default folder/sequence filename
sequence_filepath <- sprintf(directory, "\\", filename_value)
# Default folder/sequence filename
sequence_filepath <- print(paste0(directory, "\\", filename_value))
# Default folder/sequence filename
sequence_filepath <- print(paste0(directory, "\\", filename_value))
# Default folder/sequence filename
sequence_filepath <- paste0(directory, "\\", filename_value)
sequence_filepath
# Check if file exists, and if so, update sequence_filepath to unique name
sequence_filepath <- get_unique_filename(sequence_filepath)
sequence_filepath
suggested_method_folder <- r'(C:\Xcalibur\methods\Aria_C18_Methods)'
suggested_method_folder
suggested_method_folder <- r'(C:\Xcalibur\methods\Aria Methods)'
suggested_method_folder
source('RUN.R')
source('RUN.R')
source('RUN.R')
View(final_plate_data)
